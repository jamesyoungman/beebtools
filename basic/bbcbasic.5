.TH "BBC BASIC" 5 2020-05-03 \" -*- nroff -*-

.SH SYNOPSIS
Implementations of BBC BASIC store saved programs in a tokenised
format.  This is similar to (or, perhaps, the same as) the in-memory
representation of the program once loaded.

.SH "BBC BASIC DIALECTS"

There are a number of variants of the BBC BASIC language.  These vary
in both the facilities offered (the ARM version has a richer set of
keywords for example) and in how the programs are represented (there
are differences in both tokenisation and how lines are recorded).
Some dialects record lines of code with a leading ASCII Carriage
Return, others with a length byte first.  Some dialects also use some
byte values as "extension codes" which introduce a multi-byte token
representation.

The dialects described in this document are

.TS
tab(|) allbox;
lb lb lb
l l l
l l s
l l l
l l l
l l l
l l l
l l s.
Dialect|Line Encoding|Tokenisation
6502|CR first|No extension codes
32016|Identical to 6502
ARM|CR first|Extension codes 0xC6, 0xC7, 0xC8
Mac|CR first|Extension codes 0xC6, 0xC7, 0xC8
Windows|Length first|No extension codes, bytes <= 0x10 different
Z80|Length first|No extension codes
8086|Identical to Z80
.TE

Although both ARM and Mac use extension codes, the keywords encoded
with them are not always the same.

There are also some other implementations of BBC BASIC.  R. T
Russell's Windows implementation and his BBC BASIC for SDL 2.0 (which
runs on many platforms, including Linux and Mac OS X) use the same
encoding.

.SH FILE FORMAT

A BBC BASIC file is encoded as a sequence of program lines.  The
format of these lines varies between implementations.

.TS
tab(|) allbox;
l l l.
Type|Dialects|Line Format
CR-first|6502, 32016, ARM |0x0D <hi> <lo> <len> tokens...
Length-first|Z80, 8086, Windows |<len> <lo> <hi> tokens... 0x0D
.TE

Both line-encoding systems use the same general scheme for
tokenization, though the various dialects support a slightly different
set of tokens.  Each line is a sequence of tokens (see
.BR TOKENISATION
for a list).

.SS "CR-First Line Format"

In CR-first files, all lines (including the first) begin with a CR
character (hex 0x0D).  This is followed by the high byte then the low
byte of the line number, the length of the line and then the line
contents as a sequence of tokens.  Line number 25610 would be encoded
as 0x64 (decimal 100) followed by 0x0A (decimal 10).  The <len> value
counts from <hi>, so for example this line

.EX
0x0D 0x00 0x00A 0x04 0xF1
.EE

has a line number of 10 and includes just the token 0x0F1 representing "PRINT":

.EX
10 PRINT
.EE

.SS "Length-First Line Format"

In length-first files, all lines begin with a length byte.  This is
followed by two bytes of line number (low byte first), the line length
followed by a number of token bytes implied by the line length.  After
that, the following byte must be the 0x0D marking the end of the line.

The length byte encodes the total number of bytes in the line,
including the final 0x0D.  The line

.EX
0x05 0x00 0x05 0xF5 0x0D
.EE

has a line number of 10 and includes just the token 0xF5 representing "REPEAT":

.EX
10 REPEAT
.EE


.SH END OF FILE

End-of-file is represented slightly differently in the two line
encoding systems.

In CR-first files, end-of-file is encoded as 0x0D 0xFF.  By
implication, the highest representable line number would be 65279
decimal.

In length-first files, end-of-file is encoded as the line 0x00 0xFF
0xFF.  Normally the length byte would include the line number bytes,
but not in this case. The highest representable line number would be
65534 decimal.

Nothing should be read after the end-of-file marker (even though some
files do include additional bytes).

.SH TOKENISATION

Strings are represented as a double quote followed by the literal
content of the string then a final double quote.  Strings can contain
non-ASCII characters but these are not expanded as if they are tokens.
For example a string can contain the byte 0x85 but this should not be
expanded to
.BR ERROR .
Instead it should be understood to the literal byte 0x85.  Programs
sometimes contain such bytes in strings because when printed they have
an effect in Mode 7 (in this case,
.IR "alpha magenta" ).

Outside strings, bytes are either tokens or part of a line number
(see
.BR "LINE NUMBERS" ).

.SS Single-Byte Tokens 0x00 ... 0x10

Most of these tokens are valid only in the Windows dialect (hence the
unusual column order in the table below):

.TS
tab(|) allbox;
lb ab lb
l  c  s  
l  l  c
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  l  ^  
l  c  s  
l  l  c  
l  l  ^  
l  l  ^. 
Byte |Windows       | 6502 / Z80 / ARM 
0x00 |\fIinvalid\fP
0x01 |"CIRCLE"|\fIall invalid\fP
0x02 |"ELLIPSE"|
0x03 |"FILL"|
0x04 |"MOUSE"|
0x05 |"ORIGIN"|
0x06 |"QUIT"|
0x07 |"RECTANGLE"|
0x08 |"SWAP"|
0x09 |"SYS"|
0x0A |"TINT"|
0x0B |"WAIT"|
0x0C |"INSTALL"|
0x0D | Line start/end depending on dialect|
0x0E |"PRIVATE"| \fIall invalid\fP
0x0F |"BY"|
0x10 |"EXIT"|
.TE

.SS Single-Byte Tokens 0x11 ... 0x7E

Outside a string, bytes between 0x11 and 0x7E inclusive represent
themselves.  Within a string, all bytes represent themselves.  

.SS Token 0x7F

This token is valid only on ARM:

.TS
tab(|) allbox;
lb lb lb lb lb
l  c  s  l  l.
Byte|6502|Z80|ARM|Windows
0x7F|\fIinvalid\fP|"OTHERWISE"|\fIinvalid\fP
.TE


.SS Single-Byte Tokens 0x80 ... 0x8C

.TS
tab(|) allbox;
lb lb
l  c.
Byte|All Dialects
0x80|"AND"
0x81|"DIV"
0x82|"EOR"
0x83|"MOD"
0x84|"OR"
0x85|"ERROR"
0x86|"LINE"
0x87|"OFF"
0x88|"STEP"
0x89|"SPC"
0x8A|"TAB("
0x8B|"ELSE"
0x8C|"THEN"
.TE

.SS Token 0x8D

This token introduces a line number; see
.BR "LINE NUMBERS" .

.SS Tokens 0x8E ... 0xC5

.TS
tab(|) allbox;
lb lb
l  l.
Byte|All Dialects
0x8E|"OPENIN"
0x8F|"PTR"
0x90|"PAGE"
0x91|"TIME"
0x92|"LOMEM"
0x93|"HIMEM"
0x94|"ABS"
0x95|"ACS"
0x96|"ADVAL"
0x97|"ASC"
0x98|"ASN"
0x99|"ATN"
0x9A|"BGET"
0x9B|"COS"
0x9C|"COUNT"
0x9D|"DEG"
0x9E|"ERL"
0x9F|"ERR"
.TE

.TS
tab(|) allbox;
lb lb
l  l.
Byte|All Dialects
0xA0|"EVAL"
0xA1|"EXP"
0xA2|"EXT"
0xA3|"FALSE"
0xA4|"FN"
0xA5|"GET"
0xA6|"INKEY"
0xA7|"INSTR("
0xA8|"INT"
0xA9|"LEN"
0xAA|"LN"
0xAB|"LOG"
0xAC|"NOT"
0xAD|"OPENUP"
0xAE|"OPENOUT"
0xAF|"PI"
.TE

.TS
tab(|) allbox;
lb lb
l  l.
Byte|All Dialects
0xB0|"POINT("
0xB1|"POS"
0xB2|"RAD"
0xB3|"RND"
0xB4|"SGN"
0xB5|"SIN"
0xB6|"SQR"
0xB7|"TAN"
0xB8|"TO"
0xB9|"TRUE"
0xBA|"USR"
0xBB|"VAL"
0xBC|"VPOS"
0xBD|"CHR$"
0xBE|"GET$"
0xBF|"INKEY$"
0xC0|"LEFT$("
0xC1|"MID$("
0xC2|"RIGHT$("
0xC3|"STR$"
0xC4|"STRING$("
0xC5|"EOF"
.TE

The keyword
.B TOP
is encoded as 0xB8 ("TO") followed by 0x50 (ASCII P).

.SS Token 0xC6

In the ARM and Mac dialects the 0xC6 byte introduces an extension
mechanism:

.TS
tab(|) allbox;
lb   lb   lb  lb  lb  lb
l    c    s   c   s   l.
Byte|6502|Z80|ARM|Mac|Windows
0xC6|"AUTO"|\fIExtension\fP|"SUM"
.TE

In dialects where 0xC6 is an extension mechanism, the token is two
bytes long (that is, 0xC6 followed by a second byte) and expands to a
string as follows:

.TS
tab(|) allbox;
lb lb lb
l  c  s
l  c  s
l  l  l.
Second Byte after 0xC6|ARM|Mac
0x8E|"SUM"
0x8F|"BEAT"
0x90|\fIinvalid\fP|"ASK"
0x91|\fIinvalid\fP|"ANSWER"
0x92|\fIinvalid\fP|"SFOPENIN"
0x93|\fIinvalid\fP|"SFOPENOUT"
0x94|\fIinvalid\fP|"SFOPENUP"
0x95|\fIinvalid\fP|"SFNAME$"
0x96|\fIinvalid\fP|"MENU"
.TE

In the ARM dialect, the keyword
.B SUMLEN
is encoded as 0xC6 0x8E (which encode
.BR SUM )
followed by 0xA9 (which encodes
.BR LEN ).
On the other hand, in the Windows dialect,
.B SUMLEN
is encoded as 0xC6 (which encodes
.BR SUM ),
followed by 0xA9 (which encodes
.BR LEN ).

.SS Token 0xC7

In the ARM and Mac dialects, the 0xC7 byte introduces an extension
mechanism:

.TS
tab(|) allbox;
lb   lb   lb  lb  lb  lb
l    c    s   c   s   l.
Byte|6502|Z80|ARM|Mac|Windows
0xC7|"DELETE"|\fIExtension\fP|"WHILE"
.TE

The next byte identifies the expansion:

.TS
tab(|) allbox;
lb lb lb
l  c  s
l  c  s
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  l
l  l  ^.
Second Byte after 0xC7|ARM|Mac
0x8E|"APPEND"
0x8F|"AUTO"
0x90|"CRUNCH"|"DELETE"
0x91|"DELETE"|"EDIT"
0x92|"EDIT"|"HELP"
0x93|"HELP"|"LIST"
0x94|"LIST"|"LOAD"
0x95|"LOAD"|"LVAR"
0x96|"LVAR"|"NEW"
0x97|"NEW"|"OLD"
0x98|"OLD"|"RENUMBER"
0x99|"RENUMBER"|"SAVE"
0x9A|"SAVE"|"TWIN"
0x9B|"TEXTLOAD"|"TWINO"
0x9C|"TEXTSAVE"|\fIinvalid\f
0x9D|"TWIN"
0x9E|"TWINO"
0x9f|"INSTALL"
.TE

Some keywords are encoded using this prefix and an ASCII suffix:

.TS
tab(|) allbox;
lb lb lb lb
l  lb l  l.
Bytes|Dialect|Tokens|Keyword
0xC7 0x92 0x4F|ARM|"EDIT" O|"EDITO"
0xC7 0x93 0x24|Mac|"LIST" $|"LIST$"
0xC7 0x94 0x4F|ARM|"LIST" O|"LISTO"
.TE

.SS Token 0xC8

In the ARM and Mac dialects, the 0xC8 byte introduces an extension
mechanism:

.TS
tab(|) allbox;
lb lb lb lb lb lb
l  c  s  c  s  l.
Byte| 6502|Z80|ARM|Mac|Windows
0xC8|"LOAD"|\fIExtension\fP|"CASE"
.TE

For ARM and Mac, the next byte identifies the expansion:

.TS
tab(|) allbox;
lb lb
l  l .
Second Byte after 0xC8|ARM
0x8E|"CASE"
0x8F|"CIRCLE"
0x90|"FILL"
0x91|"ORIGIN"
0x92|"POINT"
0x93|"RECTANGLE"
0x94|"SWAP"
0x95|"WHILE"
0x96|"WAIT"
0x97|"MOUSE"
0x98|"QUIT"
0x99|"SYS"
0x9A|"INSTALL"
0x9B|"LIBRARY"
0x9C|"TINT"
0x9D|"ELLIPSE"
0x9E|"BEATS"
0x9F|"TEMPO"
0xA0|"VOICES"
0xA1|"VOICE"
0xA2|"STEREO"
0xA3|"OVERLAY"
0xA4|"MANDEL"
0xA5|"PRIVATE"
0xA6|"EXIT"
.TE

.SS Single-Byte Tokens 0xC9 ... 0xCE

Bytes in this range are interpreted as follows:

.TS
tab(|) allbox;
lb lb lb lb lb
l  c  s  c  s
l  c  s  c  s
l  c  s  c  s
l  c  s  l  l
l  c  s  c  s
l  l  l  c  s.
Byte|6502|Z80|ARM|Windows
0xC9|"LIST"|"WHEN"
0xCA|"NEW"|"OF"
0xCB|"OLD"|"ENDCASE"
0xCC|"RENUMBER"|"ELSE"|"OTHERWISE"
0xCD|"SAVE"|"ENDIF"
0xCE|"EDIT"|"PUT"|"ENDWHILE"
.TE

The keyword
.B TIME$
is encoded as 0xD1 0x24 (0x24 being ASCII $).

.SS Single-Byte Tokens 0xCF ... 0xFF
.TS
tab(:) allbox;
lb lb
l  l.
Byte:All Dialects
0xCF:"PTR"
0xD0:"PAGE"
0xD1:"TIME"
0xD2:"LOMEM"
0xD3:"HIMEM"
0xD4:"SOUND"
0xD5:"BPUT"
0xD6:"CALL"
0xD7:"CHAIN"
0xD8:"CLEAR"
0xD9:"CLOSE"
0xDA:"CLG"
0xDB:"CLS"
0xDC:"DATA"
0xDD:"DEF"
0xDE:"DIM"
0xDF:"DRAW"   
.TE

The keyword
.B PTR#
is encoded as 0xCF ("PTR") 0x23 (0x23 being ASCII #).


.\" There is a break between tables here just to ensure it fits on one page.

.TS
tab(:) allbox;
lb lb
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
l  l
^  l
l  l.
Byte:All Dialects
0xE0:"END"
0xE1:"ENDPROC"
0xE2:"ENVELOPE"
0xE3:"FOR"
0xE4:"GOSUB"
0xE5:"GOTO"
0xE6:"GCOL"
0xE7:"IF"
0xE8:"INPUT"
0xE9:"LET"
0xEA:"LOCAL"
0xEB:"MODE"
0xEC:"MOVE"
0xED:"NEXT"
0xEE:"ON"
0xEF:"VDU"
0xF0:"PLOT"
0xF1:"PRINT"
0xF2:"PROC"
0xF3:"READ"
0xF4:"REM"
0xF5:"REPEAT"
0xF6:"REPORT"
0xF7:"RESTORE"
0xF8:"RETURN"
0xF9:"RUN"
0xFA:"STOP"
0xFB:"COLOUR"
0xFB:"COLOR"
0xFC:"TRACE"
0xFD:"UNTIL"
0xFE:"WIDTH"
0xFF:"OSCLI"
.TE

The byte value 0xFB encodes the keyword
.BR  COLOUR .
Some dialects (for example Mac) also accept
.B COLOR
when a program is being entered but this is "corrected" to
.BR COLOUR .
The keyword
.B REPORT$
is encoded as 0xF6 ("REPORT") followed by 0x24 (ASCII $).


.SH "LINE NUMBERS"

Line numbers at the start of a line are encoded as exactly two bytes.
Within a file, they are consistently represented high byte first
(6502, 32016, ARM and probably Mac) or low byte first (Z80,
8086, Windows).

Within the rest of the line, they are represented differently. They
are introduced by the byte value 0x8D and (counting the 0x8D) always
occupy four bytes.  These line numbers are encoded in such a way that
they can be decoded as if with the following C expression (b1, b2 and
b3 are the three unsigned bytes of the line number which follow the
0x8D marker byte):

.EX
(((b3 ^  (b1 << 4)) & 0xFF) << 8) | (b2 ^ ((b1 << 2)  & 0xC0))
.EE

Some dialects allow line numbers to be omitted.  When this is the case
they are encoded as line number 0.


.SH "MAC DIALECT"
This document leans heavily on http://mdfs.net/Docs/Comp/BBCBasic/Tokens
as source material, but that document is not very explicit about how
the Mac implementation of BBC BASIC is tokenised.

The Mac dialect described in this document is the 1987 implementation
by Human-Computer Interface Ltd.  On the basis of examination of some
sample programs, I see that the Mac dialect is similar to the ARM
dialect, but some of the extension code mappings are different.

There is also an SDL version for Mac OS X implemented by
R. T. Russell, but it uses the same dialect as his Windows
implementation.

If you have additional information or corrections, please use the
contact information given in the
.B BUGS
section.

.SH CORNER CASES

There are a number of possible inputs which don't match this
description.  I don't know whether in any cases, any BBC BASIC
implementation will accept the file as a valid program, but if so this
document should be clarified to describe things in more detail.
Contributions of corrections with test cases very welcome (see
.BR BUGS ).

.TP
\(bu
Line length byte extends beyond the physical end-of-file.
.TP
\(bu
Physical EOF is reached without a preceding EOF marker
.TP
\(bu
Program line ends in the middle of a byte sequence encoding a line
number
.TP
\(bu
For CR-first files, line length byte is within a reasonable range
but the character following the end of the line is not 0x0D.  For
length-first files, the final character of the line is not 0x0D.
.TP
\(bu
Out-of-order line numbers
.TP
\(bu
It's possible that not all implementations support the full range of
theoretically-representable line numbers.

.SH SEE ALSO
\fBbbcbasic_to_text\fP(1)

http://www.rtrussell.co.uk/

http://mdfs.net/Docs/Comp/BBCBasic/Tokens

http://mdfs.net/Docs/Comp/BBCBasic/Line

.SH BUGS
Please report inaccuracies or other defects in this document to
james@youngman.org.
